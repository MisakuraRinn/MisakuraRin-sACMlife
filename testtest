# 春季集训1

## A - Easy Problem

主要是想出怎么定义状态
设$f[i][j]$为前i个字符最多连到hard第j个字母的最小模糊度
细节问题：例如$s[i]=h$时$f[i][1]=min(f[i-1][1],f[i-1][0])$
因为如果之前已经连到第一个字母h，那么再接一个字母h是对此没有影响的
然后可以使用滚动数组优化

## B - 子集 mex

首先分析题目中操作的过程，无非就是要一个个凑然后合成上去，初始凑多少个不知道，但是最后肯定只要凑出一个n，那么可以倒着统一处理
先把大的凑了，然后把需要的减去，不足的就记作负数
细节问题：极端情况下凑出n的次数是类似斐波那契数列增长的，所以要开ll

## C - Travelling Salesman and Special Numbers

### STL技巧

`__builtin_popcount()`表示括号内数的二进制表示数1的个数

总体思路就是数位dp
首先n的二进制位不超过一千位，也就是1的数量不超过一千
那么我们可以先预处理出各个1的数量要转化到1所需的操作次数`f[i]`，然后统计`f[i]=k`中的i可以对应到多少数
那么就是需要求前i位有j个1的数的数量，这就是数位Dp预处理的内容
再用根据n的大小统计累加即可
细节问题：记得考虑n本身是否合法
1转化到1的次数是0，所以在k=1时需要特判减一，然后不能在dp[1][1]处直接进行特判修改`dp[1][1]=0`，因为例如n是110，k=2，那么修改后会在idx-1=1时少计入一次101
`dp[i][j]`统计的是含前导零的情况，因为你在按位遍历n的时候是有前面接数字的，后面要接含前导零的数才能保证不漏


## D - Backpack

总体思路：背包+bitset
首先从最暴力的情况来设计状态
设`bool f[i][j][k]`为前$i$个物品使用了$j$个空间，价值异或和为是否可达
然后我们发现$j$可以进行线性运算，考虑使用bitset压缩空间和时间
然后可以将$i$滚动掉
细节问题：状态转移的时候遍历异或和时不能到1024，最多要1023，不然会溢出到至多2047
